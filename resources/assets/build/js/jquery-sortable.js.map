{"version":3,"names":[],"mappings":"","sources":["jquery-sortable.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n/* ===================================================\n *  jquery-sortable.js v0.9.13\n *  http://johnny.github.com/jquery-sortable/\n * ===================================================\n *  Copyright (c) 2012 Jonas von Andrian\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  * The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * ========================================================== */\n\n!function ($, window, pluginName, undefined) {\n    var containerDefaults = {\n        // If true, items can be dragged from this container\n        drag: true,\n        // If true, items can be droped onto this container\n        drop: true,\n        // Exclude items from being draggable, if the\n        // selector matches the item\n        exclude: \"\",\n        // If true, search for nested containers within an item.If you nest containers,\n        // either the original selector with which you call the plugin must only match the top containers,\n        // or you need to specify a group (see the bootstrap nav example)\n        nested: true,\n        // If true, the items are assumed to be arranged vertically\n        vertical: true\n    },\n        // end container defaults\n    groupDefaults = {\n        // This is executed after the placeholder has been moved.\n        // $closestItemOrContainer contains the closest item, the placeholder\n        // has been put at or the closest empty Container, the placeholder has\n        // been appended to.\n        afterMove: function afterMove($placeholder, container, $closestItemOrContainer) {},\n        // The exact css path between the container and its items, e.g. \"> tbody\"\n        containerPath: \"\",\n        // The css selector of the containers\n        containerSelector: \"ol, ul\",\n        // Distance the mouse has to travel to start dragging\n        distance: 0,\n        // Time in milliseconds after mousedown until dragging should start.\n        // This option can be used to prevent unwanted drags when clicking on an element.\n        delay: 0,\n        // The css selector of the drag handle\n        handle: \"\",\n        // The exact css path between the item and its subcontainers.\n        // It should only match the immediate items of a container.\n        // No item of a subcontainer should be matched. E.g. for ol>div>li the itemPath is \"> div\"\n        itemPath: \"\",\n        // The css selector of the items\n        itemSelector: \"li\",\n        // The class given to \"body\" while an item is being dragged\n        bodyClass: \"dragging\",\n        // The class giving to an item while being dragged\n        draggedClass: \"dragged\",\n        // Check if the dragged item may be inside the container.\n        // Use with care, since the search for a valid container entails a depth first search\n        // and may be quite expensive.\n        isValidTarget: function isValidTarget($item, container) {\n            return true;\n        },\n        // Executed before onDrop if placeholder is detached.\n        // This happens if pullPlaceholder is set to false and the drop occurs outside a container.\n        onCancel: function onCancel($item, container, _super, event) {},\n        // Executed at the beginning of a mouse move event.\n        // The Placeholder has not been moved yet.\n        onDrag: function onDrag($item, position, _super, event) {\n            $item.css(position);\n        },\n        // Called after the drag has been started,\n        // that is the mouse button is being held down and\n        // the mouse is moving.\n        // The container is the closest initialized container.\n        // Therefore it might not be the container, that actually contains the item.\n        onDragStart: function onDragStart($item, container, _super, event) {\n            $item.css({\n                height: $item.outerHeight(),\n                width: $item.outerWidth()\n            });\n            $item.addClass(container.group.options.draggedClass);\n            $(\"body\").addClass(container.group.options.bodyClass);\n        },\n        // Called when the mouse button is being released\n        onDrop: function onDrop($item, container, _super, event) {\n            $item.removeClass(container.group.options.draggedClass).removeAttr(\"style\");\n            $(\"body\").removeClass(container.group.options.bodyClass);\n        },\n        // Called on mousedown. If falsy value is returned, the dragging will not start.\n        // Ignore if element clicked is input, select or textarea\n        onMousedown: function onMousedown($item, _super, event) {\n            if (!event.target.nodeName.match(/^(input|select|textarea)$/i)) {\n                event.preventDefault();\n                return true;\n            }\n        },\n        // The class of the placeholder (must match placeholder option markup)\n        placeholderClass: \"placeholder\",\n        // Template for the placeholder. Can be any valid jQuery input\n        // e.g. a string, a DOM element.\n        // The placeholder must have the class \"placeholder\"\n        placeholder: '<li class=\"placeholder\"></li>',\n        // If true, the position of the placeholder is calculated on every mousemove.\n        // If false, it is only calculated when the mouse is above a container.\n        pullPlaceholder: true,\n        // Specifies serialization of the container group.\n        // The pair $parent/$children is either container/items or item/subcontainers.\n        serialize: function serialize($parent, $children, parentIsContainer) {\n            var result = $.extend({}, $parent.data());\n\n            if (parentIsContainer) return [$children];else if ($children[0]) {\n                result.children = $children;\n            }\n\n            delete result.subContainers;\n            delete result.sortable;\n\n            return result;\n        },\n        // Set tolerance while dragging. Positive values decrease sensitivity,\n        // negative values increase it.\n        tolerance: 0\n    },\n        // end group defaults\n    containerGroups = {},\n        groupCounter = 0,\n        emptyBox = {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0\n    },\n        eventNames = {\n        start: \"touchstart.sortable mousedown.sortable\",\n        drop: \"touchend.sortable touchcancel.sortable mouseup.sortable\",\n        drag: \"touchmove.sortable mousemove.sortable\",\n        scroll: \"scroll.sortable\"\n    },\n        subContainerKey = \"subContainers\";\n\n    /*\n     * a is Array [left, right, top, bottom]\n     * b is array [left, top]\n     */\n    function d(a, b) {\n        var x = Math.max(0, a[0] - b[0], b[0] - a[1]),\n            y = Math.max(0, a[2] - b[1], b[1] - a[3]);\n        return x + y;\n    }\n\n    function setDimensions(array, dimensions, tolerance, useOffset) {\n        var i = array.length,\n            offsetMethod = useOffset ? \"offset\" : \"position\";\n        tolerance = tolerance || 0;\n\n        while (i--) {\n            var el = array[i].el ? array[i].el : $(array[i]),\n\n            // use fitting method\n            pos = el[offsetMethod]();\n            pos.left += parseInt(el.css('margin-left'), 10);\n            pos.top += parseInt(el.css('margin-top'), 10);\n            dimensions[i] = [pos.left - tolerance, pos.left + el.outerWidth() + tolerance, pos.top - tolerance, pos.top + el.outerHeight() + tolerance];\n        }\n    }\n\n    function getRelativePosition(pointer, element) {\n        var offset = element.offset();\n        return {\n            left: pointer.left - offset.left,\n            top: pointer.top - offset.top\n        };\n    }\n\n    function sortByDistanceDesc(dimensions, pointer, lastPointer) {\n        pointer = [pointer.left, pointer.top];\n        lastPointer = lastPointer && [lastPointer.left, lastPointer.top];\n\n        var dim,\n            i = dimensions.length,\n            distances = [];\n\n        while (i--) {\n            dim = dimensions[i];\n            distances[i] = [i, d(dim, pointer), lastPointer && d(dim, lastPointer)];\n        }\n        distances = distances.sort(function (a, b) {\n            return b[1] - a[1] || b[2] - a[2] || b[0] - a[0];\n        });\n\n        // last entry is the closest\n        return distances;\n    }\n\n    function ContainerGroup(options) {\n        this.options = $.extend({}, groupDefaults, options);\n        this.containers = [];\n\n        if (!this.options.rootGroup) {\n            this.scrollProxy = $.proxy(this.scroll, this);\n            this.dragProxy = $.proxy(this.drag, this);\n            this.dropProxy = $.proxy(this.drop, this);\n            this.placeholder = $(this.options.placeholder);\n\n            if (!options.isValidTarget) this.options.isValidTarget = undefined;\n        }\n    }\n\n    ContainerGroup.get = function (options) {\n        if (!containerGroups[options.group]) {\n            if (options.group === undefined) options.group = groupCounter++;\n\n            containerGroups[options.group] = new ContainerGroup(options);\n        }\n\n        return containerGroups[options.group];\n    };\n\n    ContainerGroup.prototype = {\n        dragInit: function dragInit(e, itemContainer) {\n            this.$document = $(itemContainer.el[0].ownerDocument);\n\n            // get item to drag\n            var closestItem = $(e.target).closest(this.options.itemSelector);\n            // using the length of this item, prevents the plugin from being started if there is no handle being clicked on.\n            // this may also be helpful in instantiating multidrag.\n            if (closestItem.length) {\n                this.item = closestItem;\n                this.itemContainer = itemContainer;\n                if (this.item.is(this.options.exclude) || !this.options.onMousedown(this.item, groupDefaults.onMousedown, e)) {\n                    return;\n                }\n                this.setPointer(e);\n                this.toggleListeners('on');\n                this.setupDelayTimer();\n                this.dragInitDone = true;\n            }\n        },\n        drag: function drag(e) {\n            if (!this.dragging) {\n                if (!this.distanceMet(e) || !this.delayMet) return;\n\n                this.options.onDragStart(this.item, this.itemContainer, groupDefaults.onDragStart, e);\n                this.item.before(this.placeholder);\n                this.dragging = true;\n            }\n\n            this.setPointer(e);\n            // place item under the cursor\n            this.options.onDrag(this.item, getRelativePosition(this.pointer, this.item.offsetParent()), groupDefaults.onDrag, e);\n\n            var p = this.getPointer(e),\n                box = this.sameResultBox,\n                t = this.options.tolerance;\n\n            if (!box || box.top - t > p.top || box.bottom + t < p.top || box.left - t > p.left || box.right + t < p.left) if (!this.searchValidTarget()) {\n                this.placeholder.detach();\n                this.lastAppendedItem = undefined;\n            }\n        },\n        drop: function drop(e) {\n            this.toggleListeners('off');\n\n            this.dragInitDone = false;\n\n            if (this.dragging) {\n                // processing Drop, check if placeholder is detached\n                if (this.placeholder.closest(\"html\")[0]) {\n                    this.placeholder.before(this.item).detach();\n                } else {\n                    this.options.onCancel(this.item, this.itemContainer, groupDefaults.onCancel, e);\n                }\n                this.options.onDrop(this.item, this.getContainer(this.item), groupDefaults.onDrop, e);\n\n                // cleanup\n                this.clearDimensions();\n                this.clearOffsetParent();\n                this.lastAppendedItem = this.sameResultBox = undefined;\n                this.dragging = false;\n            }\n        },\n        searchValidTarget: function searchValidTarget(pointer, lastPointer) {\n            if (!pointer) {\n                pointer = this.relativePointer || this.pointer;\n                lastPointer = this.lastRelativePointer || this.lastPointer;\n            }\n\n            var distances = sortByDistanceDesc(this.getContainerDimensions(), pointer, lastPointer),\n                i = distances.length;\n\n            while (i--) {\n                var index = distances[i][0],\n                    distance = distances[i][1];\n\n                if (!distance || this.options.pullPlaceholder) {\n                    var container = this.containers[index];\n                    if (!container.disabled) {\n                        if (!this.$getOffsetParent()) {\n                            var offsetParent = container.getItemOffsetParent();\n                            pointer = getRelativePosition(pointer, offsetParent);\n                            lastPointer = getRelativePosition(lastPointer, offsetParent);\n                        }\n                        if (container.searchValidTarget(pointer, lastPointer)) return true;\n                    }\n                }\n            }\n            if (this.sameResultBox) this.sameResultBox = undefined;\n        },\n        movePlaceholder: function movePlaceholder(container, item, method, sameResultBox) {\n            var lastAppendedItem = this.lastAppendedItem;\n            if (!sameResultBox && lastAppendedItem && lastAppendedItem[0] === item[0]) return;\n\n            item[method](this.placeholder);\n            this.lastAppendedItem = item;\n            this.sameResultBox = sameResultBox;\n            this.options.afterMove(this.placeholder, container, item);\n        },\n        getContainerDimensions: function getContainerDimensions() {\n            if (!this.containerDimensions) setDimensions(this.containers, this.containerDimensions = [], this.options.tolerance, !this.$getOffsetParent());\n            return this.containerDimensions;\n        },\n        getContainer: function getContainer(element) {\n            return element.closest(this.options.containerSelector).data(pluginName);\n        },\n        $getOffsetParent: function $getOffsetParent() {\n            if (this.offsetParent === undefined) {\n                var i = this.containers.length - 1,\n                    offsetParent = this.containers[i].getItemOffsetParent();\n\n                if (!this.options.rootGroup) {\n                    while (i--) {\n                        if (offsetParent[0] != this.containers[i].getItemOffsetParent()[0]) {\n                            // If every container has the same offset parent,\n                            // use position() which is relative to this parent,\n                            // otherwise use offset()\n                            // compare #setDimensions\n                            offsetParent = false;\n                            break;\n                        }\n                    }\n                }\n\n                this.offsetParent = offsetParent;\n            }\n            return this.offsetParent;\n        },\n        setPointer: function setPointer(e) {\n            var pointer = this.getPointer(e);\n\n            if (this.$getOffsetParent()) {\n                var relativePointer = getRelativePosition(pointer, this.$getOffsetParent());\n                this.lastRelativePointer = this.relativePointer;\n                this.relativePointer = relativePointer;\n            }\n\n            this.lastPointer = this.pointer;\n            this.pointer = pointer;\n        },\n        distanceMet: function distanceMet(e) {\n            var currentPointer = this.getPointer(e);\n            return Math.max(Math.abs(this.pointer.left - currentPointer.left), Math.abs(this.pointer.top - currentPointer.top)) >= this.options.distance;\n        },\n        getPointer: function getPointer(e) {\n            var o = e.originalEvent || e.originalEvent.touches && e.originalEvent.touches[0];\n            return {\n                left: e.pageX || o.pageX,\n                top: e.pageY || o.pageY\n            };\n        },\n        setupDelayTimer: function setupDelayTimer() {\n            var that = this;\n            this.delayMet = !this.options.delay;\n\n            // init delay timer if needed\n            if (!this.delayMet) {\n                clearTimeout(this._mouseDelayTimer);\n                this._mouseDelayTimer = setTimeout(function () {\n                    that.delayMet = true;\n                }, this.options.delay);\n            }\n        },\n        scroll: function scroll(e) {\n            this.clearDimensions();\n            this.clearOffsetParent(); // TODO is this needed?\n        },\n        toggleListeners: function toggleListeners(method) {\n            var that = this,\n                events = ['drag', 'drop', 'scroll'];\n\n            $.each(events, function (i, event) {\n                that.$document[method](eventNames[event], that[event + 'Proxy']);\n            });\n        },\n        clearOffsetParent: function clearOffsetParent() {\n            this.offsetParent = undefined;\n        },\n        // Recursively clear container and item dimensions\n        clearDimensions: function clearDimensions() {\n            this.traverse(function (object) {\n                object._clearDimensions();\n            });\n        },\n        traverse: function traverse(callback) {\n            callback(this);\n            var i = this.containers.length;\n            while (i--) {\n                this.containers[i].traverse(callback);\n            }\n        },\n        _clearDimensions: function _clearDimensions() {\n            this.containerDimensions = undefined;\n        },\n        _destroy: function _destroy() {\n            containerGroups[this.options.group] = undefined;\n        }\n    };\n\n    function Container(element, options) {\n        this.el = element;\n        this.options = $.extend({}, containerDefaults, options);\n\n        this.group = ContainerGroup.get(this.options);\n        this.rootGroup = this.options.rootGroup || this.group;\n        this.handle = this.rootGroup.options.handle || this.rootGroup.options.itemSelector;\n\n        var itemPath = this.rootGroup.options.itemPath;\n        this.target = itemPath ? this.el.find(itemPath) : this.el;\n\n        this.target.on(eventNames.start, this.handle, $.proxy(this.dragInit, this));\n\n        if (this.options.drop) this.group.containers.push(this);\n    }\n\n    Container.prototype = {\n        dragInit: function dragInit(e) {\n            var rootGroup = this.rootGroup;\n\n            if (!this.disabled && !rootGroup.dragInitDone && this.options.drag && this.isValidDrag(e)) {\n                rootGroup.dragInit(e, this);\n            }\n        },\n        isValidDrag: function isValidDrag(e) {\n            return e.which == 1 || e.type == \"touchstart\" && e.originalEvent.touches.length == 1;\n        },\n        searchValidTarget: function searchValidTarget(pointer, lastPointer) {\n            var distances = sortByDistanceDesc(this.getItemDimensions(), pointer, lastPointer),\n                i = distances.length,\n                rootGroup = this.rootGroup,\n                validTarget = !rootGroup.options.isValidTarget || rootGroup.options.isValidTarget(rootGroup.item, this);\n\n            if (!i && validTarget) {\n                rootGroup.movePlaceholder(this, this.target, \"append\");\n                return true;\n            } else while (i--) {\n                var index = distances[i][0],\n                    distance = distances[i][1];\n                if (!distance && this.hasChildGroup(index)) {\n                    var found = this.getContainerGroup(index).searchValidTarget(pointer, lastPointer);\n                    if (found) return true;\n                } else if (validTarget) {\n                    this.movePlaceholder(index, pointer);\n                    return true;\n                }\n            }\n        },\n        movePlaceholder: function movePlaceholder(index, pointer) {\n            var item = $(this.items[index]),\n                dim = this.itemDimensions[index],\n                method = \"after\",\n                width = item.outerWidth(),\n                height = item.outerHeight(),\n                offset = item.offset(),\n                sameResultBox = {\n                left: offset.left,\n                right: offset.left + width,\n                top: offset.top,\n                bottom: offset.top + height\n            };\n            if (this.options.vertical) {\n                var yCenter = (dim[2] + dim[3]) / 2,\n                    inUpperHalf = pointer.top <= yCenter;\n                if (inUpperHalf) {\n                    method = \"before\";\n                    sameResultBox.bottom -= height / 2;\n                } else sameResultBox.top += height / 2;\n            } else {\n                var xCenter = (dim[0] + dim[1]) / 2,\n                    inLeftHalf = pointer.left <= xCenter;\n                if (inLeftHalf) {\n                    method = \"before\";\n                    sameResultBox.right -= width / 2;\n                } else sameResultBox.left += width / 2;\n            }\n            if (this.hasChildGroup(index)) sameResultBox = emptyBox;\n            this.rootGroup.movePlaceholder(this, item, method, sameResultBox);\n        },\n        getItemDimensions: function getItemDimensions() {\n            if (!this.itemDimensions) {\n                this.items = this.$getChildren(this.el, \"item\").filter(\":not(.\" + this.group.options.placeholderClass + \", .\" + this.group.options.draggedClass + \")\").get();\n                setDimensions(this.items, this.itemDimensions = [], this.options.tolerance);\n            }\n            return this.itemDimensions;\n        },\n        getItemOffsetParent: function getItemOffsetParent() {\n            var offsetParent,\n                el = this.el;\n            // Since el might be empty we have to check el itself and\n            // can not do something like el.children().first().offsetParent()\n            if (el.css(\"position\") === \"relative\" || el.css(\"position\") === \"absolute\" || el.css(\"position\") === \"fixed\") offsetParent = el;else offsetParent = el.offsetParent();\n            return offsetParent;\n        },\n        hasChildGroup: function hasChildGroup(index) {\n            return this.options.nested && this.getContainerGroup(index);\n        },\n        getContainerGroup: function getContainerGroup(index) {\n            var childGroup = $.data(this.items[index], subContainerKey);\n            if (childGroup === undefined) {\n                var childContainers = this.$getChildren(this.items[index], \"container\");\n                childGroup = false;\n\n                if (childContainers[0]) {\n                    var options = $.extend({}, this.options, {\n                        rootGroup: this.rootGroup,\n                        group: groupCounter++\n                    });\n                    childGroup = childContainers[pluginName](options).data(pluginName).group;\n                }\n                $.data(this.items[index], subContainerKey, childGroup);\n            }\n            return childGroup;\n        },\n        $getChildren: function $getChildren(parent, type) {\n            var options = this.rootGroup.options,\n                path = options[type + \"Path\"],\n                selector = options[type + \"Selector\"];\n\n            parent = $(parent);\n            if (path) parent = parent.find(path);\n\n            return parent.children(selector);\n        },\n        _serialize: function _serialize(parent, isContainer) {\n            var that = this,\n                childType = isContainer ? \"item\" : \"container\",\n                children = this.$getChildren(parent, childType).not(this.options.exclude).map(function () {\n                return that._serialize($(this), !isContainer);\n            }).get();\n\n            return this.rootGroup.options.serialize(parent, children, isContainer);\n        },\n        traverse: function traverse(callback) {\n            $.each(this.items || [], function (item) {\n                var group = $.data(this, subContainerKey);\n                if (group) group.traverse(callback);\n            });\n\n            callback(this);\n        },\n        _clearDimensions: function _clearDimensions() {\n            this.itemDimensions = undefined;\n        },\n        _destroy: function _destroy() {\n            var that = this;\n\n            this.target.off(eventNames.start, this.handle);\n            this.el.removeData(pluginName);\n\n            if (this.options.drop) this.group.containers = $.grep(this.group.containers, function (val) {\n                return val != that;\n            });\n\n            $.each(this.items || [], function () {\n                $.removeData(this, subContainerKey);\n            });\n        }\n    };\n\n    var API = {\n        enable: function enable() {\n            this.traverse(function (object) {\n                object.disabled = false;\n            });\n        },\n        disable: function disable() {\n            this.traverse(function (object) {\n                object.disabled = true;\n            });\n        },\n        serialize: function serialize() {\n            return this._serialize(this.el, true);\n        },\n        refresh: function refresh() {\n            this.traverse(function (object) {\n                object._clearDimensions();\n            });\n        },\n        destroy: function destroy() {\n            this.traverse(function (object) {\n                object._destroy();\n            });\n        }\n    };\n\n    $.extend(Container.prototype, API);\n\n    /**\n     * jQuery API\n     *\n     * Parameters are\n     *   either options on init\n     *   or a method name followed by arguments to pass to the method\n     */\n    $.fn[pluginName] = function (methodOrOptions) {\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        return this.map(function () {\n            var $t = $(this),\n                object = $t.data(pluginName);\n\n            if (object && API[methodOrOptions]) return API[methodOrOptions].apply(object, args) || this;else if (!object && (methodOrOptions === undefined || (typeof methodOrOptions === \"undefined\" ? \"undefined\" : _typeof(methodOrOptions)) === \"object\")) $t.data(pluginName, new Container($t, methodOrOptions));\n\n            return this;\n        });\n    };\n}(jQuery, window, 'sortable');\n\n},{}]},{},[1]);\n"],"file":"jquery-sortable.js","sourceRoot":"/source/"}